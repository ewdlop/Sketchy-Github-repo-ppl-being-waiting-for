# 🎃

ChatGPT: 這裡是幾個「萬聖節主題」的 **Sketchy SQL Queries**（詭異、搞怪又帶點駭客風格）🎃，純屬幽默與教學用途，請勿在真實生產資料庫上執行。
所有例子均安全可測試（只查詢不改資料），並附上解釋。

---

## 🧛‍♂️ 1. 找出「幽靈紀錄」

```sql
SELECT *
FROM users
WHERE last_login IS NULL
  OR deleted_at IS NOT NULL;
```

**說明**：
這些帳號從沒登入過或早就「被刪除」卻還在資料庫裡──最像「幽靈」的存在。

---

## 🧙‍♀️ 2. 詛咒觸發紀錄

```sql
SELECT id, username, COUNT(*) AS curse_count
FROM logs
WHERE message LIKE '%forbidden%' OR message LIKE '%unauthorized%'
GROUP BY id, username
HAVING curse_count > 3;
```

**說明**：
找出多次觸發「禁忌」操作的使用者。
3 次以上 = 已經中了 SQL 詛咒。

---

## 🪦 3. 從墳墓爬出的資料

```sql
SELECT *
FROM products
WHERE discontinued = 1
  AND DATEDIFF(DAY, deleted_at, GETDATE()) > 365;
```

**說明**：
列出「死而復生」超過一年的商品。
適合用來清理資料庫的「殭屍資料」。

---

## 🧟‍♂️ 4. 連結兩個世界

```sql
SELECT u.username, o.order_id
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.user_id IS NULL;
```

**說明**：
這查詢會找到「沒有任何訂單」的使用者。
他們就像在人間行走的「無主魂」。

---

## 🕸️ 5. 蜘蛛網查詢（循環引用）

```sql
WITH RECURSIVE spider_web AS (
  SELECT id, parent_id, name
  FROM categories
  WHERE parent_id IS NULL
  UNION ALL
  SELECT c.id, c.parent_id, c.name
  FROM categories c
  JOIN spider_web s ON c.parent_id = s.id
)
SELECT * FROM spider_web;
```

**說明**：
用遞迴 CTE 爬整棵分類樹。
但若資料出現循環（self-loop），這查詢會陷入無盡的「蜘蛛網」。

---

## 🩸 6. 隱藏的血跡（Red Flags）

```sql
SELECT *
FROM transactions
WHERE amount < 0
  OR description LIKE '%error%'
  OR status IN ('failed', 'reversed');
```

**說明**：
抓出「異常交易」──像血跡一樣的警訊。
紅旗不只是節慶顏色。

---

## 🎃 Bonus：隨機召喚一筆記錄

```sql
SELECT TOP 1 *
FROM victims -- 呃…假設這是個 Halloween Table 名稱
ORDER BY NEWID();
```

**說明**：
每次執行都隨機召喚一筆資料。
你永遠不知道會叫出誰。

---

📚 **SQL 語法參考資料**：

* Microsoft Docs – [Transact-SQL Reference](https://learn.microsoft.com/en-us/sql/t-sql/language-reference)
* PostgreSQL Documentation – [SQL Syntax and CTEs](https://www.postgresql.org/docs/current/queries-with.html)

---

## 💀 7. SQL Injection 範例（教育用途）

### ❌ 不安全的查詢（脆弱點）

```python
# 危險：直接將使用者輸入串接到 SQL 查詢中
username = input("Enter username: ")
password = input("Enter password: ")

# 這樣寫會有 SQL Injection 風險！
query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
cursor.execute(query)
```

**攻擊範例**：
```
Username: admin' --
Password: 隨便輸入
```

**結果查詢**：
```sql
SELECT * FROM users WHERE username = 'admin' --' AND password = '隨便輸入'
```

`--` 會註解掉後面的密碼檢查，攻擊者可以繞過認證！

---

### ✅ 安全的查詢（防禦方法）

```python
# 安全：使用參數化查詢（Parameterized Query）
username = input("Enter username: ")
password = input("Enter password: ")

# 使用占位符 %s，資料庫驅動會自動處理跳脫
query = "SELECT * FROM users WHERE username = %s AND password = %s"
cursor.execute(query, (username, password))
```

**為什麼安全？**
- 資料庫會將使用者輸入當作「資料」而非「SQL 程式碼」
- 自動處理特殊字元的跳脫（escape）
- 無法改變查詢的結構

---

### 🕷️ 更多攻擊範例

#### 1. 繞過登入
```
Username: ' OR '1'='1' --
Password: 任意
```

#### 2. 取得所有資料
```
productId=1 UNION SELECT username, password FROM users --
```

#### 3. 刪除資料表（如果允許多語句執行）
```
userId=1; DROP TABLE users; --
```

---

### 🛡️ 防禦最佳實踐

1. **永遠使用參數化查詢或 Prepared Statements**
   - Python: `cursor.execute(query, (param1, param2))`
   - Node.js: `connection.query(query, [param1, param2])`
   - PHP PDO: `$stmt->execute(['param' => $value])`
   - Java JDBC: `pstmt.setString(1, value)`

2. **使用 ORM（Object-Relational Mapping）**
   - SQLAlchemy (Python)
   - Sequelize (Node.js)
   - Eloquent (PHP/Laravel)
   - Hibernate (Java)

3. **輸入驗證（第二道防線）**
   - 檢查資料型別（例如：ID 必須是數字）
   - 限制輸入長度
   - 白名單過濾
   - **注意**：驗證不能取代參數化查詢！

4. **最小權限原則**
   - 應用程式不應使用 root/admin 帳號連接資料庫
   - 只給予必要的權限（SELECT、INSERT 等）

5. **錯誤處理**
   - 不要將詳細的資料庫錯誤訊息顯示給使用者
   - 記錄錯誤用於除錯，但只回傳通用訊息

---

## 📖 延伸閱讀

### 安全資源：
* OWASP – [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
* [OWASP Top 10 - Injection](https://owasp.org/www-project-top-ten/)
* [CWE-89: SQL Injection](https://cwe.mitre.org/data/definitions/89.html)

### 測試工具：
* **SQLMap** - 自動化 SQL Injection 檢測工具
* **OWASP ZAP** - Web 應用程式安全掃描器
* **Burp Suite** - 專業安全測試工具

---

**記住**：對抗 SQL Injection 的唯一可靠方法是使用**參數化查詢**或 **Prepared Statements**。單純的輸入驗證是不夠的！

🎃 Happy (Secure) Halloween Coding! 🎃
